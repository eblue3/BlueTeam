                                                                   How CPU Works
*** Memory & Storage
Data Memory = RAM.
Computer Memory = Most often is RAM or ROM. Called "Primary Storage".
Primary Storage = Computer Memory
Secondary Storage = External Storage (SSD/HDD/...)
Program memory typically refers to flash memory when it is used to hold the program (instructions).
- Execute "a sequence of stored-instructions" <=> "a program"
- Instructions to be executed are kept in "Computer Memory" (RAM/ROM)

*** Instruction Register & CPU Units
- MAR = Memory Address register
- MDR = Memory Data register
- MBR = Memory Buffer register
- CIR = Current Instruction register
- CU  = Control Unit
- ALU = Arithmetic Logic Unit
- FPU = Floating Point Unit

--------------------------------------
|           START OF CYCLE           |
--------------------------------------
                  ||
                  VV
--------------------------------------
|     Address in Program Counter     |
|           copied to MAR            |
--------------------------------------
                  ||
                  VV
--------------------------------------
|   Program Counter incremented to   |
|   "point" to the next instruction  |
--------------------------------------
                  ||
                  VV
--------------------------------------
|   Instruction found at address     |
|   described by MAR is copied to    |
|  the MDR (hold "data" for later)   |
--------------------------------------



* Nearly/Almost all CPUs follow the "Instruction-cycle":

      1, Fetch
  # Retrieving an Instruction from RAM/ROM. The Instruction's location (address) in Program Memory (PMem) is determined by the "Program Counter" (Instruction Pointer)
  => "Program Counter" == <eip> or <iar> (Instruction Address Register), stores an address of the next instruction to be fetched
          Example of Processor Access Order:
          0x080484ae      mov dword [eax], 0x47414c46
          0x080484b4      mov dword [eax + 4], 0x3930342d
          0x47414c46 = GALF in PMem
          0x3930342d = 904- in PMem
  https://en.wikipedia.org/wiki/Endianness: "The Intel x86 and AMD64 / x86-64 series of processors use the little-endian format"
  Ref: https://cnx.org/contents/Y9Ps2snV@1/CPU-Structure-And-Functions
  So... When fetching bytes from Register to PMem
    => Processor stores data in reverse-byte sequence.
      => When the Processor gets the "numeric data" (hexadecimal data format, like "47414c46" or "3930342d") from PMem to Register, it again reverses the bytes
        => 0x47414c46 = FLAG in Register
        => 0x3930342d = -409 in Register
  => It only happens if we move data into register or store it in PMem. It won't be reversed if we us "db/dd/..." to define the data.
  Example:   msg: db  'Hello, World!'
  # After an instruction is fetched, the PC is incremented by the length of the instruction so that it will contain the address of the next instruction in the sequence
  # Often, the instruction to be fetched must be retrieved from relatively slow memory, causing the CPU to stall while waiting for the instruction to be returned
  => This issue is largely addressed in modern processors by caches and pipeline architectures

      2, Decode
  # The Instruction was fetched from PMem by CPU determines what will CPU do.

      3, Execute
  # After the fetch and decode steps, the execute step is performed.
  # Depending on the CPU architecture, this may consist of a single action or a sequence of actions

***Reference:
1.  Get next instruction
2.  Decode (i.e., interpret its meaning) the instruction
3.  Read Source Operands
4.  Perform Operation (e.g., add two numbers)
5.  Write Result
6.  Determine which is the next instruction
https://www.eecg.utoronto.ca/~moshovos/ECE243/l05-instruction-representation-stored-program.html

 ----------------------------------------------------------------------------- ## -----------------------------------------------------------------------------

                                                                    Basic Syntax
*** Sections
*** Define an area in Memory that stores the data/code/...
  1, DATA:
  - Declaring initialized data or constants.
  - This data does not change at runtime.
  - We can declare values, file names, or buffer size, etc.
  Syntax & Example:
section.data
  message:  db  'Hello, world!', 0xA, 0   ; text message
                                          ; 0xA (10) is hex for (NL = New Line), carriage return
                                          ; 0 terminates the line

  2, BSS (Block Starting Symbol - Static memory section contains buffer for data to be declared):
  - Declared Variable.
  - Only declare HOW MUCH BYTES the Variable uses. Actual data is declared on .data section.
  Syntax & Example:
section .bss
  variable: resb 4      ; The symbol variable now refers to the address of 4 bytes of storage in the .bss section
                        ; (i.e. enough to store a 32-bit value in).
  ...
section .text
  ...
  mov eax, 123
  mov [variable], eax   ; Sets the eax register to 123, and then stores the value of eax in the location addressed by the symbol variable.
  mov eax, [variable]   ; Reads the value currently stored in the location addressed by variable into the eax register.
  ...
  mov eax, 456
  mov [variable], eax   ; Stores a new value, overwriting the previous one.

  3, CODE/TEXT
  - Actual Code
  - Begin with the declaration " global _start" (or _main) to tell kernel where the program execution begins.
  Syntax & Example:
section .text
  global _start
_start:
  ...

 ----------------------------------------------------------------------------- ## -----------------------------------------------------------------------------

                                                    Assembly Language Statements

  Assembly language programs consist of three types of statements âˆ’
  - Executable instructions or instructions.
  The executable instructions or simply instructions tell the processor what to do.
  Each instruction consists of an operation code (opcode). Each executable instruction generates one machine language instruction.
  Ex:
    mov eax, 10
    add eax, 10
    ...

  - Assembler directives or pseudo-ops.
  The assembler directives or pseudo-ops tell the assembler about the various aspects of the assembly process.
  These are non-executable and do not generate machine language instructions.
  Ex:
    .common, .global, .local, .weak
=>
    .pushsection    ".data"
    .global   foo1        ! int foo1 = 1
    .align    4
    foo1:
    .word  0x1
    .type  foo1,#object   ! foo1 is of type data object,
    .size  foo1,4         ! with size = 4 bytes
    .weak  foo2           ! #pragma weak foo2 = foo1
    foo2 = foo1
    .local  foo3          ! static int foo3
    .common  foo3,4,4
    .align  4             ! static int foo4 = 2
    foo4:
    .word  0x2
    .type  foo4,#object
    .size  foo4,4
    .popsection
    ...

  - Macros.
  Macros are basically a text substitution mechanism.
  Ex:
    %macro macro_name  number_of_params
    <macro body>
    %endmacro

 ----------------------------------------------------------------------------- ## -----------------------------------------------------------------------------
